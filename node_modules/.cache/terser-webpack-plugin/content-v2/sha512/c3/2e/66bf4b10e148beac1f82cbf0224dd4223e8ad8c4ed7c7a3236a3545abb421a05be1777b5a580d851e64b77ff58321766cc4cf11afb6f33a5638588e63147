{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{191:function(t,a,e){\"use strict\";e.r(a);var s=e(0),r=Object(s.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,a=t.$createElement,e=t._self._c||a;return e(\"div\",{staticClass:\"content\"},[e(\"h1\",{attrs:{id:\"js-的事件循环-event-loop-机制\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#js-的事件循环-event-loop-机制\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" Js 的事件循环(Event Loop)机制\")]),t._v(\" \"),e(\"h2\",{attrs:{id:\"js是单线程\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#js是单线程\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" Js是单线程\")]),t._v(\" \"),e(\"ul\",[e(\"li\",[e(\"p\",[t._v(\"js作为主要运行在浏览器的脚本语言，js主要用途之一是操作DOM。\")])]),t._v(\" \"),e(\"li\",[e(\"p\",[t._v(\"如果js同时有两个线程，同时对同一个dom进行操作，这时浏览器不知道应该听哪个线程的，无法判断优先级。\")])]),t._v(\" \"),e(\"li\",[e(\"p\",[t._v(\"所以为了避免这种问题，Js必须是单线程的。\")])])]),t._v(\" \"),e(\"h2\",{attrs:{id:\"执行栈\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#执行栈\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" 执行栈\")]),t._v(\" \"),e(\"ul\",[e(\"li\",[t._v(\"当执行某个函数、用户点击一次鼠标，Ajax完成，一个图片加载完成等事件发生时，只要指定过回调函数，这些事件发生时就会进入执行栈队列中，等待主线程读取,遵循先进先出原则。\")])]),t._v(\" \"),e(\"h2\",{attrs:{id:\"主线程\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#主线程\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" 主线程\")]),t._v(\" \"),e(\"ul\",[e(\"li\",[e(\"p\",[t._v(\"主线程规定现在执行执行栈中的哪个事件。\")])]),t._v(\" \"),e(\"li\",[e(\"p\",[t._v(\"主线程循环：即主线程会不停的从执行栈中读取事件，会执行完所有栈中的同步代码。\")])]),t._v(\" \"),e(\"li\",[e(\"p\",[t._v(\"当遇到一个异步事件后，并不会一直等待异步事件返回结果，而是会将这个事件挂在与执行栈不同的队列中，我们称之为==任务队列(Task Queue)==。\")])])]),t._v(\" \"),e(\"h2\",{attrs:{id:\"js-异步执行的运行机制\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#js-异步执行的运行机制\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" js 异步执行的运行机制\")]),t._v(\" \"),e(\"ol\",[e(\"li\",[e(\"p\",[t._v(\"所有任务都在主线程上执行，形成一个执行栈。\")])]),t._v(\" \"),e(\"li\",[e(\"p\",[t._v('主线程之外，还存在一个\"任务队列\"（task queue）。只要异步任务有了运行结果，就在\"任务队列\"之中放置一个事件。')])]),t._v(\" \"),e(\"li\",[e(\"p\",[t._v('一旦\"执行栈\"中的所有同步任务执行完毕，系统就会读取\"任务队列\"。那些对应的异步任务，结束等待状态，进入执行栈并开始执行。')])]),t._v(\" \"),e(\"li\",[e(\"p\",[t._v(\"主线程不断重复上面的第三步。\")])])]),t._v(\" \"),e(\"h2\",{attrs:{id:\"宏任务与微任务\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#宏任务与微任务\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" 宏任务与微任务\")]),t._v(\" \"),e(\"ul\",[e(\"li\",[t._v(\"异步任务分为 宏任务（macrotask） 与 微任务 (microtask)，不同的API注册的任务会依次进入自身对应的队列中，然后等待 Event Loop 将它们依次压入执行栈中执行。\")])]),t._v(\" \"),e(\"h3\",{attrs:{id:\"宏任务-macrotask-：\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#宏任务-macrotask-：\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" 宏任务(macrotask)：\")]),t._v(\" \"),e(\"ul\",[e(\"li\",[t._v(\"script(整体代码)、setTimeout、setInterval、UI 渲染、 I/O、postMessage、 MessageChannel、setImmediate(Node.js 环境)\")])]),t._v(\" \"),e(\"h3\",{attrs:{id:\"微任务-microtask-：\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#微任务-microtask-：\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" 微任务(microtask)：\")]),t._v(\" \"),e(\"ul\",[e(\"li\",[t._v(\"Promise、 MutaionObserver、process.nextTick(Node.js环境）\")])]),t._v(\" \"),e(\"h2\",{attrs:{id:\"event-loop-事件循环-：\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#event-loop-事件循环-：\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" Event Loop(事件循环)：\")]),t._v(\" \"),e(\"ul\",[e(\"li\",[e(\"p\",[t._v(\"Event Loop(事件循环)中，每一次循环称为 tick, 每一次tick的任务如下：\")]),t._v(\" \"),e(\"ol\",[e(\"li\",[t._v(\"执行栈选择最先进入队列的宏任务(通常是script整体代码)，如果有则执行\")]),t._v(\" \"),e(\"li\",[t._v(\"检查是否存在 Microtask，如果存在则不停的执行，直至清空 microtask 队列\")]),t._v(\" \"),e(\"li\",[t._v(\"更新render(每一次事件循环，浏览器都可能会去更新渲染)\")]),t._v(\" \"),e(\"li\",[t._v(\"重复以上步骤\")])])])]),t._v(\" \"),e(\"p\",[e(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2018/6/16/164081cfd8400f92?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\",alt:\"image\"}})])])}],!1,null,null,null);a.default=r.exports}}]);","extractedComments":[]}