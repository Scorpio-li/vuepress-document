(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{178:function(e,r,a){"use strict";a.r(r);var i=a(0),t=Object(i.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,r=e.$createElement,a=e._self._c||r;return a("div",{staticClass:"content"},[a("h1",{attrs:{id:"浏览器的缓存机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#浏览器的缓存机制","aria-hidden":"true"}},[e._v("#")]),e._v(" 浏览器的缓存机制")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("缓存可以说是性能优化中简单高效的一种优化方式了。")])]),e._v(" "),a("li",[a("p",[e._v("一个优秀的缓存策略可以缩短网页请求资源的距离，减少延迟，并且由于缓存文件可以重复利用，还可以减少带宽，降低网络负荷。")])])]),e._v(" "),a("p",[a("img",{attrs:{src:"https://upload-images.jianshu.io/upload_images/3174701-8e74b69ad9376710?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp",alt:"image"}})]),e._v(" "),a("h2",{attrs:{id:"缓存位置"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缓存位置","aria-hidden":"true"}},[e._v("#")]),e._v(" 缓存位置")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("从缓存位置上来说分为四种，并且各自有优先级，当依次查找缓存且都没有命中的时候，才会去请求网络。")]),e._v(" "),a("ol",[a("li",[e._v("Service Worker")]),e._v(" "),a("li",[e._v("Memory Cache")]),e._v(" "),a("li",[e._v("Disk Cache")]),e._v(" "),a("li",[e._v("Push Cache")])])])]),e._v(" "),a("h3",{attrs:{id:"_1-service-worker"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-service-worker","aria-hidden":"true"}},[e._v("#")]),e._v(" 1.Service Worker")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。")])]),e._v(" "),a("li",[a("p",[e._v("使用 Service Worker的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。")])]),e._v(" "),a("li",[a("p",[e._v("Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。")])]),e._v(" "),a("li",[a("p",[e._v("Service Worker 实现缓存功能一般分为三个步骤：")]),e._v(" "),a("ol",[a("li",[a("p",[e._v("首先需要先注册 Service Worker，")])]),e._v(" "),a("li",[a("p",[e._v("然后监听到 install 事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。")])]),e._v(" "),a("li",[a("p",[e._v("如果我们没有在 Service Worker 命中缓存的话，会根据缓存查找优先级去查找数据。但是不管我们是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示我们是从 Service Worker 中获取的内容。")])])])])]),e._v(" "),a("h3",{attrs:{id:"_2-memory-cache"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-memory-cache","aria-hidden":"true"}},[e._v("#")]),e._v(" 2.Memory Cache")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("Memory Cache 也就是内存中的缓存，主要包含的是当前中页面中已经抓取到的资源,例如页面上已经下载的样式、脚本、图片等。")])]),e._v(" "),a("li",[a("p",[e._v("读取内存中的数据肯定比磁盘快,内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。")])]),e._v(" "),a("li",[a("p",[e._v("内存缓存在缓存资源时并不关心返回资源的HTTP缓存头Cache-Control是什么值，同时资源的匹配也并非仅仅是对URL做匹配，还可能会对Content-Type，CORS等其他特征做校验。")])])]),e._v(" "),a("h3",{attrs:{id:"_3-disk-cache"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-disk-cache","aria-hidden":"true"}},[e._v("#")]),e._v(" 3.Disk Cache")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("Disk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache 胜在容量和存储时效性上。")])]),e._v(" "),a("li",[a("p",[e._v("Disk Cache 覆盖面基本是最大的。它会根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。")])])]),e._v(" "),a("h3",{attrs:{id:"_4-push-cache"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-push-cache","aria-hidden":"true"}},[e._v("#")]),e._v(" 4.Push Cache")]),e._v(" "),a("ul",[a("li",[e._v("Push Cache（推送缓存）是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。它只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂，在Chrome浏览器中只有5分钟左右，同时它也并非严格执行HTTP头中的缓存指令。")])]),e._v(" "),a("hr"),e._v(" "),a("h2",{attrs:{id:"浏览器缓存策略"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#浏览器缓存策略","aria-hidden":"true"}},[e._v("#")]),e._v(" 浏览器缓存策略")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("缓存策略都是通过设置 HTTP Header 来实现的")])]),e._v(" "),a("li",[a("p",[e._v("根据是否需要向服务器重新发起HTTP请求将缓存过程分为两个部分")])])]),e._v(" "),a("h3",{attrs:{id:"强缓存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#强缓存","aria-hidden":"true"}},[e._v("#")]),e._v(" 强缓存")]),e._v(" "),a("p",[e._v("不会向服务器发送请求，直接从缓存中读取资源，在chrome控制台的Network选项中可以看到该请求返回200的状态码，并且Size显示from disk cache或from memory cache。强缓存可以通过设置两种 HTTP Header 实现：Expires 和 Cache-Control。")]),e._v(" "),a("ol",[a("li",[a("p",[e._v("Expires")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。也就是说，Expires=max-age + 请求时间，需要和Last-modified结合使用。Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。")])]),e._v(" "),a("li",[a("p",[e._v("Expires 是 HTTP/1 的产物，受限于本地时间，如果修改了本地时间，可能会造成缓存失效。Expires: Wed, 22 Oct 2018 08:41:00 GMT表示资源会在 Wed, 22 Oct 2018 08:41:00 GMT 后过期，需要再次请求。")])])])]),e._v(" "),a("li",[a("p",[e._v("Cache-Control")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("在HTTP/1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存。比如当Cache-Control:max-age=300时，则代表在这个请求正确返回时间（浏览器也会记录下来）的5分钟内再次加载资源，就会命中强缓存。")])]),e._v(" "),a("li",[a("p",[e._v("Cache-Control 可以在请求头或者响应头中设置，并且可以组合使用多种指令：")])])]),e._v(" "),a("p",[a("img",{attrs:{src:"https://upload-images.jianshu.io/upload_images/3174701-8ff981603cdfded0?imageMogr2/auto-orient/strip%7CimageView2/2/w/562/format/webp",alt:"image"}})]),e._v(" "),a("ul",[a("li",[e._v("public: 所有内容都将被缓存（客户端和代理服务器都可缓存）。具体来说响应可被任何中间节点缓存，如 Browser <-- proxy1 <--  proxy2 <-- Server，中间的proxy可以缓存资源，比如下次再请求同一资源proxy1直接把自己缓存的东西给 Browser 而不再向proxy2要。")])])])]),e._v(" "),a("h3",{attrs:{id:"协商缓存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#协商缓存","aria-hidden":"true"}},[e._v("#")]),e._v(" 协商缓存")]),e._v(" "),a("hr"),e._v(" "),a("h2",{attrs:{id:"缓存过程分析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缓存过程分析","aria-hidden":"true"}},[e._v("#")]),e._v(" 缓存过程分析")]),e._v(" "),a("ul",[a("li",[e._v("浏览器与服务器通信的方式为应答模式，即是：浏览器发起HTTP请求 – 服务器响应该请求，那么浏览器怎么确定一个资源该不该缓存，如何去缓存呢？浏览器第一次向服务器发起该请求后拿到请求结果后，将请求结果和缓存标识存入浏览器缓存，浏览器对于缓存的处理是根据第一次请求资源时返回的响应头来确定的。")])]),e._v(" "),a("p",[a("img",{attrs:{src:"https://upload-images.jianshu.io/upload_images/3174701-de3d6e025582103a?imageMogr2/auto-orient/strip%7CimageView2/2/w/670/format/webp",alt:"image"}})]),e._v(" "),a("ul",[a("li",[a("p",[e._v("浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识")])]),e._v(" "),a("li",[a("p",[e._v("浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中")])])])])}],!1,null,null,null);r.default=t.exports}}]);